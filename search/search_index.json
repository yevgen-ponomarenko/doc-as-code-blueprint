{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Documentation Product","text":"<p>The Documentation as Code Blueprint is static web-site built by using Material for MkDocs Documentation Tool and deployed on GitHub pages via CI/CD pipeline implemented in GitHub Actions Workflows.</p> <p>To search for specific documentation please use Searh feature https://squidfunk.github.io/mkdocs-material/plugins/search/ as well as left navigation menu.</p>"},{"location":"about/","title":"About","text":"<p>Welcome to the public repository Doc as Code Blueprint!</p>"},{"location":"about/#repository-information","title":"Repository Information","text":"<p>Repository URL: Doc as Code Blueprint</p> <p>This repository serves as a blueprint for implementing documentation as code. It exemplifies best practices, templates, configurations, and tools required to maintain and manage documentation efficiently using code-based approaches.</p>"},{"location":"about/#author","title":"Author","text":"<p>Author: Yevgen Ponomarenko</p>"},{"location":"about/#linkedin-profile","title":"LinkedIn Profile","text":"<p>Connect with me on LinkedIn: Yevgen Ponomarenko</p>"},{"location":"about/#professional-background","title":"Professional Background","text":"<p>I am Yevgen Ponomarenko, a seasoned Data Delivery Manager with vast experience in managing projects and programs of various scales. My expertise spans across project management, data management, and the implementation of \"documentation as code\" methodology to streamline and enhance documentation processes.</p> <p>Thank you for visiting the Doc as Code Blueprint repository. Feel free to explore the resources and connect with me for any queries or collaboration opportunities.</p>"},{"location":"project-management/change-management-process/","title":"Scope Change Management","text":""},{"location":"project-management/change-management-process/#summary","title":"Summary","text":"<p>Scope Change Management is a vital process in project management to ensure that any proposed changes to the project scope are identified, assessed, and handled effectively. This process is in alignment with best practices provided by PMBOK (Project Management Body of Knowledge) and DMBoK (Data Management Body of Knowledge).</p> <p></p>"},{"location":"project-management/change-management-process/#identify","title":"Identify","text":""},{"location":"project-management/change-management-process/#project-stakeholders","title":"Project Stakeholders","text":"<p>The first step in change management is identifying all project stakeholders. These are individuals or groups who:  - Have a vested interest in the outcome of the project.  - Are affected by the project.  - Can influence the project.</p> <p>Knowing the stakeholders is crucial as they can provide valuable input, identify potential issues, and help in managing and communicating changes effectively.</p>"},{"location":"project-management/change-management-process/#establish","title":"Establish","text":""},{"location":"project-management/change-management-process/#scope-baseline","title":"Scope Baseline","text":"<p>The second step is to establish the project's scope baseline. The scope baseline is a key project document that includes:   - Project scope statement.   - Work breakdown structure (WBS).   - WBS dictionary.</p> <p>It serves as a reference point against which project performance is measured and project changes are controlled. Establishing a scope baseline ensures that any changes are measured and managed effectively.</p>"},{"location":"project-management/change-management-process/#follow","title":"Follow","text":""},{"location":"project-management/change-management-process/#change-request-management","title":"Change Request Management","text":"<p>Change Request Management involves tracking and processing all changes to the project scope. It comprises three main stages:</p> <ol> <li>Intake:</li> <li>Collect change requests from stakeholders.</li> <li> <p>Ensure that the change requests are documented and logged appropriately.</p> </li> <li> <p>Impact Analysis:</p> </li> <li>Analyze the impact of proposed changes on project scope, schedule, cost, quality, and resources.</li> <li> <p>Assess risks associated with the change.</p> </li> <li> <p>Processing &amp; Execution:</p> </li> <li>Approve or reject changes based on the impact analysis.</li> <li>If approved, update the relevant project documents and communicate the change to all stakeholders.</li> <li>Implement and execute the change as per the approved plan.</li> </ol>"},{"location":"project-management/change-management-process/#recap","title":"Recap","text":"<p>Summarizing the above stages ensures a structured approach to managing changes in project scope. By identifying stakeholders, establishing a clear scope baseline, and following a well-defined change management process (Intake, Impact Analysis, Processing &amp; Execution), project teams can effectively manage scope changes, minimizing disruptions and enhancing project success.</p>"},{"location":"release-management/release-it/","title":"Release Management","text":"<p>Warning</p> <p>This page is given as example of integration with MkDocs-Build-Plantuml-Plugin and draw.io</p> <p>Release Types:</p> <ul> <li>Sprint Release  - promoted to PROD by the end of each Sprint. Name pattern - <code>&lt;Sprint Name&gt; Release</code>, e.g. 2025.01.S1 Release</li> <li>Mid-quater and Quater Release (Product Driven) - promoted to PROD by the mid and end of each quater (~3 Sprints). Name pattern - <code>&lt;YEAR&gt;.&lt;QUARTER&gt;.R&lt;RELEASE_NUMBER&gt;</code>, e.g. 2025.Q1.R1</li> <li>Ad-hoc release, &gt;TBD, e.g. 2025.Q1.Product_Dashboard_Release</li> </ul>"},{"location":"release-management/release-it/#etlelt-sprint-release-process","title":"ETL/ELT Sprint Release Process","text":"<ul> <li>GitHub Repository -  <li>PROD Releases Schedule - bi-weekly Sprint End Date +- 2 b/d</li>"},{"location":"release-management/release-it/#etl-release-release-engineer-activities-sprint-timeline-diagram","title":"ETL Release: Release Engineer activities Sprint timeline diagram","text":""},{"location":"release-management/release-it/#etl-release-use-case-diagram","title":"ETL Release: Use case diagram","text":""},{"location":"release-management/release-it/#gitflow-branching-strategy","title":"(GitFlow) Branching Strategy","text":"<p>GitFlow is a branching model that supports multiple environments such as Development (DEV), Quality Assurance (QA), User Acceptance Testing (UAT), and Production (PROD). In this workflow, the process of integrating your code changes with the main code base and deploying it to various environments is facilitated through a Continuous Integration (CI) and Continuous Delivery (CD) pipeline. </p> <p>Following this CI/CD process using GitFlow, your team can achieve an efficient workflow that enables continuous integration, testing, and deployment across multiple environments: DEV, QA, UAT, and PROD. This ensures code quality, helps minimize risk, and accelerates the speed of software delivery.</p> <p>Here's an overview of the CI/CD process using GitFlow for the mentioned deployment environments.</p>"},{"location":"release-management/release-it/#branch-types-and-naming-conventions","title":"Branch types and naming conventions:","text":"<ul> <li><code>main</code>: The production-ready code.</li> <li><code>develop</code>: The main branch for development, where all developers merge their work.</li> <li><code>feature</code>: Branches for new features, branching from and merging back to develop. Feature Git branch names should be prefixed with type of work as <code>(feat|fix|refactoring|chore)/&lt;JIRA_TICKET_ID&gt;/&lt;SHORT_DESC&gt;</code> where:<ul> <li>feat - is a feature (i.e. user story)</li> <li>fix - is a fix of bug found in non-PROD environment</li> <li>refactoring - refactoring tickets</li> <li>chore - something that doesn't fall into above categories (e.g. documentation, code clean-up, comments, etc.). We prefer to not commit anything without a JIRA ticket but if the exception is reasonable then those branches shoud use <code>TECH-0000</code> instead of <code>&lt;JIRA_TICKET_ID&gt;</code></li> </ul> </li> <li><code>releases</code>: Branches for release preparation, branching from develop and merging back to main and develop. Naming - <code>releases/&lt;RELEASE_ID&gt;</code></li> <li><code>hotfix</code>: Branches for fixing critical production bugs, branching from main and merging back to main and develop. Hotfix branches should include release id in branch name (i.e. <code>hotfix/&lt;RELEASE_ID&gt;/&lt;JIRA_TICKET_ID&gt;/&lt;SHORT_DESC&gt;</code>)</li> </ul>"},{"location":"release-management/release-it/#gitflow-enviromments","title":"(GitFlow) Enviromments","text":"<ol> <li> <p>Development (DEV): Developers create new feature branches from the <code>develop</code> branch and work on their tasks individually. Once done, developers submit a Pull Request (PR) to merge their code changes back into the develop branch.</p> </li> <li> <p>Quality Assurance (QA): Once the PR is merged into the <code>develop</code> branch, QA engineers can deploy the latest version of the code from the develop branch to the QA environment for functional, performance, and security testing.</p> </li> <li> <p>User Acceptance Testing (UAT): If the tests are successful in the QA environment, a release branch is created from the <code>develop</code> branch. The release branch is then deployed to the UAT environment, where stakeholders can test and validate the changes. Any issues identified during this stage should be fixed in the release branch, which triggers the CI process for the fixes.</p> </li> <li> <p>Production (PROD): After successful UAT, the release branch is merged into the <code>main</code> branch, and the updated application is ready to be deployed to the Production environment. The CI/CD pipeline ensures that the main branch goes through the complete build, test, and validation stages before deployment.</p> </li> </ol> <p>Continuous Integration (CI): Upon submitting a PR, an automated CI process is triggered. This process includes building the application, running unit tests, and checking code quality using static code analysis tools. If the CI process is successful, the PR can be reviewed and approved by a peer or a senior team member.</p> <p>Hotfixes: If there is a need to fix a critical issue in the production environment, a hotfix branch is created directly from the <code>main</code> branch. The hotfix will go through its own CI process and be tested in the QA and UAT environments. Once approved, the hotfix branch is merged back into both <code>main</code> and <code>develop</code> branches.</p>"},{"location":"release-management/release-it/#gitflow-data-engineering-happy-path-use-cases","title":"(GitFlow) Data Engineering Happy Path use-cases:","text":""},{"location":"release-management/release-it/#gitflow-data-engineering-bug-fix-use-cases","title":"(GitFlow) Data Engineering Bug Fix use-cases:","text":""},{"location":"release-management/release-it/#gitflow-data-engineering-hotfix-use-cases","title":"(GitFlow) Data Engineering Hotfix use-cases:","text":""},{"location":"release-management/release-it/#development-conventions","title":"Development conventions","text":""},{"location":"release-management/release-it/#commits","title":"Commits","text":"<p>Rules of thumb:</p> <ul> <li>Prefix your commits as <code>TECH-XXX:...</code></li> <li>Prefer to make more commits and shorter messages</li> </ul>"},{"location":"release-management/release-it/#pull-requests","title":"Pull Requests","text":"<p>Rules of thumb:</p> <ul> <li>Prefer \"Comment\" over \"Request Changes\"</li> <li>Prefix your pull requests as <code>TECH-XXX:...</code></li> <li>Provide summary of what was done. Include links on related artifacts (Jira tickets, diagrams, documentation, etc.)</li> <li>Use \"Squash and Merge\" instead of \"Merge\" for feature branch into develop to keep Git history shorter</li> <li>In all other cases use \"Merge\"</li> <li>Delete your branch after merge to base</li> </ul>"},{"location":"release-management/release-it/#release-to-uat-step-by-step-example","title":"Release to UAT Step-by-Step Example","text":"<p>Consider that you would want to deploy a set of commits found on the <code>develop</code> branch to <code>UAT</code>. In terms of this step-by-step guide, the proper deployment of the first sprint's release for 2024 is going to be presented.</p> <ol> <li>Create a properly named release branch from the <code>main</code> branch. In our example, create the <code>releases/2025.S1</code> from the <code>main</code> branch.</li> <li>From the GitHub page, create a pull request that merges the <code>develop</code> branch to the newly created release branch. In our case, the pull request should have <code>releases/2025.S1</code> as base branch. As part of this pull request:<ul> <li>Include all team leads along with other legit reviewers. Bear in mind that everyone in this list is considered a legit approver.</li> <li>Write a descriptive list of all the user stories delivered in terms of this release. Specifically, include:<ul> <li>The link to the corresponding JIRA Release, if any</li> <li>The list of all user stories delivered, as a list of properly named links to the corresponding JIRA ticket numbers.</li> <li>The list of all possible detected defects founds during the QA phase.</li> <li>A proper example of a descriptive list can be found on the  <li>Once approved, merge the changes. It should be boldly underlined that changes should be merged and NOT \"squashed and merged\".</li> <li>Go to GitHub's <code>Actions</code> tab and check the progress of the automated deployment to UAT.</li>"},{"location":"release-management/release-it/#release-to-prod-step-by-step-example","title":"Release to PROD Step-by-Step Example","text":"<p>Consider that you would want to deploy to the <code>PROD</code> environment, a set of commits that have been already deployed and tested to <code>UAT</code>,  In terms of this step-by-step guide, the proper deployment of the first sprint's release for 2024 is going to be presented.</p> <ol> <li>Having created a proper release branch and automatically deployed to the <code>UAT</code> environment, a \"UAT sign off\" request should be made to PO.</li> <li>Having PO's approval on the aforementioned \"UAT sign off\" request, create a pull request in GitHub having the <code>main</code> branch as base, and the release branch as comparison. In our example's case, this would be <code>releases/2025.S1</code>. As in case of the <code>UAT</code> release, please include:<ul> <li>Include all team leads along with other legit reviewers. Bear in mind that everyone in this list is considered a legit approver.</li> <li>Write a descriptive list of all the user stories delivered in terms of this release along with the Sprint goal objectives. A proper example of a suitable description can be found on the  <li>Once approved, merge the changes. It should be boldly underlined that changes should be merged and NOT \"squashed and merged\".</li> <li>Go to GitHub's <code>Actions</code> tab and communicate the link of the automated deployment to PROD to appropriate stakeholders to approve.</li>"},{"location":"release-management/release-it/#hotfix-release-step-by-step-example","title":"Hotfix Release Step-by-Step Example","text":"<p>Consider the case of deploying a hotfix to the <code>PROD</code> environment. In terms of this step-by-step guide, consider the case of delivering the code changes introduced in terms of imaginary ticket TECH-1234, which have already been merged to the <code>develop</code> branch, while the latest release branch is <code>releases/2024.S1</code>.</p> <ol> <li>Create a properly named hotfix branch from the latest release branch. In our case, the following GitHub command should be issued: <pre><code>git checkout -b hotfix/2025.S1/TECH-1234/Update-Something releases/2025.S1\n</code></pre></li> <li>Knowing the commit id of the hotfix, cherry-pick it to the hotfix branch. Specifically in our case, assuming that the requested commit id is <code>e99c429</code>, the command that should be issued is the: <pre><code>git cherry-pick e99c429\n</code></pre></li> <li>Push the changes to make a pull request that should be merged in the latest realase branch that in our case is <code>releases/2025.S1</code>.<ul> <li>Include all team leads along with other stakeholders as legit reviewers. Bear in mind that everyone in this list is considered a legit approver.</li> <li>Write a descriptive list of all the user stories delivered in terms of this hotfix. A proper example of a descriptive list can be found on the  <li>Once approved, merge the changes. It should be boldly underlined that changes should be merged and NOT \"squashed and merged\".</li> <li>Go to GitHub's <code>Actions</code> tab and check the progress of the automated deployment to UAT.</li> <li>After the necessary smoke testing in the <code>UAT</code> environment, make a \"UAT sign off\" request to PO.</li> <li>Having PO's approval on the \"UAT sign off\" request, create a pull request in GitHub having the <code>main</code> branch as base, and the release branch as comparison. In our example's case, this would be <code>releases/2025.S1</code>. As in case of the <code>UAT</code> release, please include: <ul> <li>Include all team leads along with other legit reviewers. Bear in mind that everyone in this list is considered a legit approver.</li> <li>Write a descriptive list of all the user stories delivered in terms of this release along with the Sprint goal objectives.</li> </ul> </li> <li>Once approved, merge the changes. It should be boldly underlined that changes should be merged and NOT \"squashed and merged\".</li> <li>Go to GitHub's <code>Actions</code> tab and communicate the link of the automated deployment to PROD to either legit stakeholders, since they only have the authority for production deployment.</li>"},{"location":"release-management/release-it/#bi-sdlc-release-management","title":"BI SDLC / Release Management","text":"<p>Tip</p> <p>Please refresh with cache reload if you don't see Draw.io embedding below</p> <p></p>"}]}